package Algorithm_Training.考研真题;
/*
链接：https://www.nowcoder.com/questionTerminal/376537f4609a49d296901db5139639ec
来源：牛客网

搬运一下思路：
记f(n)为n的划分数，我们有递推公式：

    f(2m + 1) = f(2m)，
f(2m) = f(2m - 1) + f(m)，
初始条件：f(1) = 1。

    证明:

    证明的要点是考虑划分中是否有1。

    记:
A(n) = n的所有划分组成的集合，
B(n) = n的所有含有1的划分组成的集合，
C(n) = n的所有不含1的划分组成的集合，
则有: A(n) = B(n)∪C(n)。

    又记:
f(n) = A(n)中元素的个数，
g(n) = B(n)中元素的个数，
h(n) = C(n)中元素的个数，
易知: f(n) = g(n) + h(n)。

    以上记号的具体例子见文末。

    我们先来证明: f(2m + 1) = f(2m)，
首先，2m + 1 的每个划分中至少有一个1，去掉这个1，就得到 2m 的一个划分，故 f(2m + 1)≤f(2m)。
其次，2m 的每个划分加上个1，就构成了 2m + 1 的一个划分，故 f(2m)≤f(2m + 1)。
综上，f(2m + 1) = f(2m)。

    接着我们要证明: f(2m) = f(2m - 1) + f(m)，
把 B(2m) 中的划分中的1去掉一个，就得到 A(2m - 1) 中的一个划分，故 g(2m)≤f(2m - 1)。
把 A(2m - 1) 中的划分加上一个1，就得到 B(2m) 中的一个划分，故 f(2m - 1)≤g(2m)。
综上，g(2m) = f(2m - 1)。

    把 C(2m) 中的划分的元素都除以2，就得到 A(m) 中的一个划分，故 h(2m)≤f(m)。
把 A(m) 中的划分的元素都乘2，就得到 C(2m) 中的一个划分，故 f(m)≤h(2m)。
综上，h(2m) = f(m)。

    所以: f(2m) = g(2m) + h(2m) = f(2m - 1) + f(m)。

    这就证明了我们的递推公式。

 */


import java.util.*;

public class 整数拆分 {
    public static int kinds(int n) {
        int[] f = new int[n+1];
        f[1] = 1;
        for (int i=2; i<n+1; i++) {
            f[i] = i%2==1 ? f[i-1]%1000000000 : (f[i/2]+f[i-1])%1000000000;
        }
        return f[n];
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        System.out.println(kinds(N));
    }
}


/*
题目描述
一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。
输入描述:
每组输入包括一个整数：N(1<=N<=1000000)。
输出描述:
对于每组数据，输出f(n)%1000000000。
示例1
输入
7
输出
6
 */
